任务管理
================================================================================

任务（Task）是处理器可以分配、调度、执行和挂起的一个工作单元。它可用于执行程序、任务或进程、操作系统服务、中断或异常处理过程和内核代码。

80x86提供了一种机制，这种机制可用来保存任务的状态、分派任务执行以及从一个任务切换到另一个任务。
当工作在保护模式下，处理器所有运行都在任务中。即使是简单系统也必须至少定义一个任务。
更为复杂的系统可以使用处理器的任务管理功能来支持多任务应用。

80x86提供了多任务的硬件支持。任务是一个正在运行的程序，或者是一个等待准备运行的程序。通过中断、异常、跳转或调用，我们可以执行一个任务。
当这些控制转移形式之一和某个描述符表中指定项的内容一起使用时，那么这个描述符就是一类导致新任务开始执行的描述符。

描述符表中与任务相关的描述符有两类：任务状态段描述符和任务门。当执行权传给这任何一类描述符时，都会造成任务切换。

任务切换很像过程调用，但会保存更多的处理器状态信息。任务切换会把控制权完全转移到一个新的执行环境，即新任务的执行环境。
这种转移操作要求保存处理器中几乎所有寄存器的当前内容，包括标志寄存器EFLAGS和所有段寄存器。与过程不同，任务不可重入。
任务切换不会把任何信息压入堆栈中，处理器的状态信息都被保存在内存中称为任务状态段（Task state segment）的数据结构中。

任务的结构和状态
--------------------------------------------------------------------------------

一个任务由两部分构成：任务执行空间和TSS。

* 任务执行空间包括代码段、堆栈段和一个或多个数据段，如下图所示:
  如果操作系统使用了处理器的特权级保护机制，那么任务执行空间就需要为每个特权级提供一个独立的堆栈空间。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/task_space.png

* TSS指定了构成任务执行空间的各个段，并且为任务状态信息提供存储空间。在多任务环境中，TSS也为任务之间的链接提供了处理方法。

一个任务的使用由指向其TSS的段选择符来指定。 当一个任务被加载进处理器中执行时，
那么该任务的段选择符、基地址、段限长以及TSS段描述符属性就会被加载进任务寄存器TR（Task Register）中。
如果使用了分页机制，那么任务使用的页目录表基地址就会被加载进控制寄存器CR3中。当前执行任务的状态由处理器的以下内容组成：

* 所有通用寄存器和段寄存器信息。
* 标志寄存器EFLAGS、程序指针EIP、控制寄存器CR3、任务寄存器和LDTR寄存器。
* 段寄存器指定的任务当前执行空间。
* I/O映射位图基地址和I/O位图信息（在TSS中）。
* 特权级0、1和2的堆栈指针（在TSS中）。
* 链接至前一个任务的链指针（在TSS中）。

任务的执行
--------------------------------------------------------------------------------

软件或处理器可以使用以下方法之一来调度执行一个任务：

* 使用CALL指令明确地调用一个任务。
* 使用JMP指令明确地跳转到一个任务（Linux内核使用的方式）。
* 由处理器隐含地调用一个中断句柄处理任务。
* 隐含地调用一个异常句柄处理任务。

所有这些调度任务执行的方法都会使用一个指向任务门或任务TSS段的选择符来确定一个任务。
当使用CALL或JMP指令调度一个任务时，指令中的选择符既可以直接选择任务的TSS，也可以选择存放有TSS选择符的任务门。
当调度一个任务来处理一个中断或异常时，IDT中该中断或异常表项必须是一个任务门，并且其中含有中断或异常处理任务的TSS选择符。

当调度一个任务执行时，当前正在运行任务和调度任务之间会自动地发生任务切换操作。

在任务切换期间，当前运行任务的执行环境（称为任务的状态或上下文）会被保存到它的TSS中并且暂停该任务的执行。
此后新调度任务的上下文会被加载进处理器中，并且从加载的EIP指向的指令处开始执行新任务。
如果当前执行任务（调用者）调用了被调度的新任务（被调用者），那么调用者的TSS段选择符会被保存在被调用者TSS中，
从而提供了一个返回调用者的链接。对于所有80x86 处理器，任务是不可递归调用的，即任务不能调用或跳转到自己。
中断或异常可以通过切换到一个任务来进行处理。在这种情况下，处理器不仅能够执行任务切换来处理中断或异常，
而且也会在中断或异常处理任务返回时自动地切换回被中断的任务中去。这种操作方式可以处理在中断任务执行时发生的中断。
作为任务切换操作的一部分，处理器也会切换到另一个LDT，从而允许每个任务对基于LDT的段具有不同逻辑到物理地址的映射。
同时，页目录寄存器CR3也会在切换时被重新加载，因此每个任务可以有自己的一套页表。这些保护措施能够用来隔绝各个任务并且防止它们相互干扰。

使用处理器的任务管理功能来处理多任务应用是任选的。我们也可以使用软件来实现多任务，使得每个软件定义的任务在一个80x86体系结构的任务上下文中执行。

任务管理数据结构
--------------------------------------------------------------------------------

处理器定义了以下支持多任务的寄存器和数据结构：

* 任务状态段TSS;
* TSS描述符
* 任务寄存器TR;
* 任务门描述符和标志寄存器EFLAGS中的NT标志。

使用这些数据结构，处理器可以从一个任务切换到另一个任务，同时保存原任务的上下文，以允许任务重新执行。

### 任务状态段

用于恢复一个任务执行的处理器状态信息被保存在称为任务状态段（Task State Segment，TSS）的段中。
下图给出了32位 CPU使用的TSS的格式。TSS段中各字段可分成两大类：动态字段和静态字段。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/tss.png

##### 动态字段

当任务切换而被挂起时，处理器会更新动态字段的内容。这些字段包括：

* 通用寄存器字段。用于保存EAX、ECX、EDX、EBX、ESP、EBP、ESI和EDI寄存器的内容。
* 段选择符字段。用于保存ES、CS、SS、DS、FS和GS段寄存器的内容。
* 标志寄存器EFLAGS字段。在切换之前保存EFLAGS。
* 指令指针EIP字段。在切换之前保存EIP寄存器内容。
* 先前任务链接字段。含有前一个任务TSS段选择符（在调用、中断或异常激发的任务切换时更新）。
  该字段（通常也称为后链接字段（Back link field））允许任务使用IRET指令切换到前一个任务。

##### 静态字段

处理器会读取静态字段的内容，但通常不会改变它们。这些字段内容是在任务被创建时设置的。这些字段有：

* LDT段选择符字段。含有任务的LDT段的选择符。
* CR3控制寄存器字段。含有任务使用的页目录物理基地址。
  控制寄存器CR3通常也被称为页目录基地址寄存器（Page directory base register，PDBR）。
* 特权级0、1和2的堆栈指针字段。这些堆栈指针由堆栈段选择符（SS0、SS1和SS2）和栈中偏移量指针（ESP0、ESP1和ESP2）组成。
  注意，对于指定的一个任务，这些字段的值是不变的。因此，如果任务中发生堆栈切换，寄存器SS和ESP的内容将会改变。
* 调试陷阱（Debug Trap）T标志字段。该字段位于字节0x64位0处。当设置了该位时，处理器切换到该任务的操作将产生一个调试异常。
* I/O位图基地址字段。该字段含有从TSS段开始处到I/O许可位图处的16位偏移值。

如果使用了分页机制，那么在任务切换期间应该避免处理器操作的TSS段（前104字节）中含有内存页边界。
如果TSS这部分包含内存页边界，那么该边界处两边的页面都必须同时并且连续存在于内存中。
另外，如果使用了分页机制，那么与原任务TSS和新任务TSS相关的页面，以及对应的描述符表表项应该是可读写的。

### TSS描述符

与其他段一样，任务状态段TSS也是使用段描述符来定义。下图给出了TSS描述符的格式。TSS描述符只能存放在GDT中。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/tss_descriptor.png

类型字段TYPE中的忙标志B用于指明任务是否处于忙状态。忙状态的任务是当前正在执行的任务或等待执行（被挂起）的任务。
值为0b1001的类型字段表明任务处于非活动状态；而值为0b1011的类型字段表示任务正忙。
任务是不可以递归执行的，因此处理器使用忙标志B来检测任何企图对被中断执行任务的调用。

其中基地址、段限长、描述符特权级DPL、颗粒度G和存在位具有与数据段描述符中相应字段同样的功能。
当G=0时，限长字段必须具有等于或大于103（0x67）的值，即TSS段的最小长度不得小于104字节。
如果TSS段中还包含I/O许可位图，那么TSS段长度需要大一些。另外，如果操作系统还想在TSS段中存放其他一些信息，那么TSS段就需要更大的长度。

使用调用或跳转指令，任何可以访问TSS描述符的程序都能够造成任务切换。可以访问TSS描述符的程序其CPL数值必须小于或等于TSS描述符的DPL。
在大多数系统中，TSS描述符的DPL字段值应该设置成小于3。这样，只有具有特权级的软件可以执行任务切换操作。
然而在多任务应用中，某些TSS的DPL可以设置成3，以使得在用户特权级上也能进行任务切换操作。

可访问一个TSS段描述符并没有给程序读写该描述符的能力。若想读或修改一个TSS段描述符，可以使用映射到内存相同位置的数据段描述符（即别名描述符）来操作。
把TSS描述符加载进任何段寄存器将导致一个异常。企图使用TI标志置位的选择符（即当前LDT中的选择符）来访问TSS段也将导致异常。

### 任务寄存器

任务寄存器（Task Register，TR）中存放着16位的段选择符以及当前任务TSS段的整个描述符（不可见部分）。
这些信息是从GDT中当前任务的TSS描述符中复制过来的。处理器使用任务寄存器TR的不可见部分来缓冲TSS段描述符内容。
指令LTR和STR分别用于加载和保存任务寄存器的可见部分，即TSS段的选择符。LTR指令只能被特权级0的程序执行。
LTR指令通常用于系统初始化期间给TR寄存器加载初值（如任务0的TSS段选择符），随后在系统运行期间，TR的内容会在任务切换时自动被改变。

### 任务门描述符

任务门描述符（Task Gate Descriptor）提供对一个任务间接、受保护的引用，其格式如下图所示:

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/task_gate_descriptor.png

任务门描述符可以被存放在GDT、LDT或IDT表中。
任务门描述符中的TSS选择符字段指向GDT中的一个TSS段描述符。这个TSS选择符字段中的RPL域不用。
任务门描述符中的DPL用于在任务切换时控制对TSS段的访问。当程序通过任务门调用或跳转到一个任务时，
程序的CPL以及指向任务门的门选择符的RPL值必须小于或等于任务门描述符中的DPL。请注意，当使用任务门时，目标TSS段描述符的DPL忽略不用。

程序可以通过任务门描述符或者TSS段描述符来访问一个任务。图4-36示出了LDT、GDT和IDT表中的任务门如何都指向同一个任务。

任务切换
--------------------------------------------------------------------------------

处理器可使用以下4种方式之一执行任务切换操作：

* 当前任务对GDT中的TSS描述符执行JMP或CALL指令。
* 当前任务对GDT或LDT中的任务门描述符执行JMP或CALL指令。
* 中断或异常向量指向IDT表中的任务门描述符。
* 当EFLAGS中的NT标志置位时当前任务执行IRET指令。

JMP、CALL和IRET指令以及中断和异常都是处理器的普通机制，可用于不发生任务切换的环境中。
对于TSS描述符或任务门的引用（当调用或跳转到一个任务），或者NT标志的状态（当执行IRET指令时）确定了是否会发生任务切换。
为了进行任务切换，JMP或CALL指令能够把控制转移到TSS描述符或任务门上。使用这两种方式的作用相同，
都会导致处理器把控制转移到指定的任务中，如下图所示:

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/task_schedule.png

当中断或异常的向量索引的是IDT中的一个任务门时，一个中断或异常就会造成任务切换。如果向量索引的是IDT中的一个中断或陷阱门，则不会造成任务切换。
中断服务过程总是把执行权返回到被中断的过程中，被中断的过程可能在另一个任务中。如果NT标志处于复位状态，则执行一般返回处理。
如果NT标志是置位状态，则返回操作会产生任务切换。切换到的新任务由中断服务过程TSS中的TSS选择符（前一任务链接字段）指定。
当切换到一个新任务时，处理器会执行以下操作：

* 从作为JMP或CALL指令操作数中，或者从任务门中，或者从当前TSS的前一任务链接字段（对于由IRET引起的任务切换）中取得新任务的TSS段选择符。
* 检查当前任务是否允许切换到新任务。把数据访问特权级规则应用到JMP和CALL指令上。
  当前任务的CPL和新任务段选择符的RPL必须小于或等于TSS段描述符的DPL，或者引用的是一个任务门。
  无论目标任务门或TSS段描述符的DPL是何值，异常、中断（除了使用INT n指令产生的中断）和IRET指令都允许执行任务切换。
  对于INT n指令产生的中断将检查DPL。
* 检查新任务的TSS描述符是标注为存在的（P=1），并且TSS段长度有效（大于0x67）。当试图执行会产生错误的指令时，
  都会恢复对处理器状态的任何改变。这使得异常处理过程的返回地址指向出错指令，而非出错指令随后的一条指令。
  因此异常处理过程可以处理出错条件并且重新执行任务。异常处理过程的介入处理对应用程序来说是完全透明的。
* 如果任务切换产生自JMP或IRET指令，处理器就会把当前任务（老任务）TSS描述符中的忙标志B复位；
  如果任务切换是由CALL指令、异常或中断产生，则忙标志B不动。
* 如果任务切换由IRET产生，则处理器会把临时保存的EFLAGS映像中的NT标志复位；
  如果任务切换由CALL、JMP指令或者异常或中断产生，则不用改动上述NT标志。
* 把当前任务的状态保存到当前任务的TSS中。处理器会从任务寄存器中取得当前任务TSS的基地址，
  并且把以下寄存器内容复制到当前TSS中：所有通用寄存器、段寄存器中的段选择符、标志寄存器EFLAGS以及指令指针EIP。
* 如果任务切换是由CALL指令、异常或中断产生，则处理器就会把从新任务中加载的EFLAGS中的NT标志置位。
  如果任务切换产生自JMP或IRET指令，就不改动新加载EFLAGS中的标志。
* 如果任务切换是由CALL、JMP指令或者异常或中断产生的，处理器就会设置新任务TSS描述符中的忙标志B。如果任务切换由IRET产生，则不去改动B标志。
* 使用新任务TSS的段选择符和描述符加载任务寄存器TR（包括隐藏部分）。设置CR0寄存器的TS标志。
* 把新任务的TSS状态加载进处理器。这包括LDTR寄存器、PDBR（CR3）寄存器、EFLAGS寄存器、EIP寄存器以及通用寄存器和段选择符。
  在此期间检测到的任何错误都将出现在新任务的上下文中。
* 开始执行新任务（对于异常处理过程，新任务的第一条指令显现出还没有执行）。

当成功地进行了任务切换操作，当前执行任务的状态总是会被保存起来。当任务恢复执行时，
任务将从保存的EIP指向的指令处开始执行，并且所有寄存器都恢复到任务挂起时的值。
当执行任务切换时，新任务的特权级与原任务的特权级没有任何关系。新任务在CS寄存器的CPL字段指定的特权级上开始运行。
因为各个任务通过它们独立的地址空间和TSS段相互隔绝，并且特权级规则已经控制对TSS的访问，所以在任务切换时软件不需要再进行特权级检查。

每次任务切换都会设置控制寄存器CR0中的任务切换标志TS。该标志对系统软件非常有用。
系统软件可用TS标志来协调处理器和浮点协处理器之间的操作。TS标志表明协处理器中的上下文可能与当前任务的不一致。

任务链
--------------------------------------------------------------------------------

TSS的前一任务链接（Backlink）字段以及EFLAGS中的NT标志用于返回到前一个任务操作中。
NT标志指出了当前执行的任务是否嵌套在另一个任务中执行，并且当前任务的前一任务链接字段中存放着嵌套层中更高层任务的TSS选择符（若有的话）.
如下图所示:

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/task_list.png

当CALL指令、中断或异常造成任务切换，处理器把当前TSS段的选择符复制到新任务TSS段的前一任务链接字段中，
然后在EFLAGS中设置NT标志。NT标志指明TSS的前一任务链接字段中存放有保存的TSS段选择符。
如果软件使用IRET指令挂起新任务，处理器就会使用前一任务链接字段中值和NT标志返回到前一个任务。
即如果NT标志是置位的话，处理器会切换到前一任务链接字段指定的任务去执行。

注意，当任务切换是由JMP指令造成的，那么新任务就不会是嵌套的，即NT标志会被设置为0，并且不使用前一任务链接字段。JMP指令用于不希望出现嵌套的任务切换中。

下表总结了任务切换期间，忙标志B（在TSS段描述符中）、NT标志、前一任务链接字段和TS标志（在CR0中）的用法。
注意，运行于任何特权级上的程序都可以修改NT标志，因此任何程序都可以设置NT标志并执行IRET指令。
这种做法会让处理器去执行当前任务TSS的前一任务链接字段指定的任务。为了避免这种伪造的任务切换执行成功，操作系统应该把每个TSS的该字段初始化为0。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/task_NT.png

任务地址空间
--------------------------------------------------------------------------------

任务的地址空间由任务能够访问的段构成。这些段包括代码段、数据段、堆栈段、TSS中引用的系统段以及任务代码能够访问的任何其他段。
这些段都被映射到处理器的线性地址空间中，并且随后被直接地或者通过分页机制映射到处理器的物理地址空间中。

TSS中的LDT字段可以用于给出每个任务自己的LDT。对于一个给定的任务，通过把与任务相关的所有段描述符放入LDT中，任务的地址空间就可以与其他任务隔绝开来。
当然，几个任务也可以使用同一个LDT。这是一种简单而有效的允许某些任务互相通信或控制的方法，而无须抛弃整个系统的保护屏障。
因为所有任务都可以访问GDT，所以也同样可以创建通过此表访问的共享段。

如果开启了分页机制，则TSS中的CR3寄存器字段可以让每个任务有它自己的页表。或者，几个任务能够共享相同页表集。

### 把任务映射到线性和物理地址空间

有两种方法可以把任务映射到线性地址空间和物理地址空间：

* 所有任务共享一个线性到物理地址空间的映射。当没有开启分页机制时，就只能使用这个办法。
  不开启分页时，所有线性地址映射到相同的物理地址上。当开启了分页机制，那么通过让所有任务使用一个页目录，
  我们就可以使用这种从线性到物理地址空间的映射形式。如果支持需求页虚拟存储技术，则线性地址空间可以超过现有物理地址空间的大小。
* 每个任务有自己的线性地址空间，并映射到物理地址空间。通过让每个任务使用不同的页目录，我们就可以使用这种映射形式。
  因为每次任务切换都会加载PDBR（控制寄存器CR3），所以每个任务可以有不同的页目录。

不同任务的线性地址空间可以映射到完全不同的物理地址上。如果不同页目录的条目（表项）指向不同的页表，
而且页表也指向物理地址中不同的页面上，那么各个任务就不会共享任何物理地址。
对于映射任务线性地址空间的这两种方法，所有任务的TSS都必须存放在共享的物理地址空间区域中，并且所有任务都能访问这个区域。
为了让处理器执行任务切换而读取或更新TSS时，TSS地址的映射不会改变，就需要使用这种映射方式。
GDT所映射的线性地址空间也应该映射到共享的物理地址空间中。否则就丧失了GDT的作用。

### 任务逻辑地址空间

为了在任务之间共享数据，可使用下列方法之一来为数据段建立共享的逻辑到物理地址空间的映射：

* 通过使用GDT中的段描述符。所有任务必须能够访问GDT中的段描述符。如果GDT中的某些段描述符指向线性地址空间中的一些段，
  并且这些段被映射到所有任务共享的物理地址空间中，那么所有任务都可以共享这些段中的代码和数据。

* 通过共享的LDT。两个或多个任务可以使用相同的LDT，如果它们的TSS中LDT字段指向同一个LDT。
  如果一个共享的LDT中某些段描述符指向映射到物理地址空间公共区域的段，那么共享LDT的所有任务可以共享这些段中的所有代码和数据。
  这种共享方式要比通过GDT来共享好，因为这样做可以把共享局限于指定的一些任务中。系统中有与此不同LDT的其他任务没有访问这些共享段的权利。

* 通过映射到线性地址空间公共地址区域的不同LDT中的段描述符。如果线性地址空间中的这个公共区域对每个任务都映射到物理地址空间的相同区域，
  那么这些段描述符就允许任务共享这些段。这样的段描述符通常称为别名段。这个共享方式要比上面给出的方式更好，
  因为LDT中的其他段描述符可以指向独立的未共享线性地址区域。