中断和异常处理
================================================================================
中断和异常处理

中断（Interrupt）和异常（Exception）是指明系统、处理器或当前执行程序（或任务）的某处出现一个事件，该事件需要处理器进行处理。
通常，这种事件会导致执行控制被强迫从当前运行程序转移到被称为中断处理程序（interrupt handler）
或异常处理程序（exception handler）的特殊软件函数或任务中。处理器响应中断或异常所采取的行动被称为中断/异常服务（处理）。

通常，中断发生在程序执行的随机时刻，以响应硬件发出的信号。系统硬件使用中断来处理外部事件,
例如要求为外部设备提供服务。当然，软件也能通过执行INT n指令产生中断。

异常发生在处理器执行一条指令时，检测到一个出错条件时发生，例如被0除出错条件。
处理器可以检测到各种出错条件，包括违反保护机制、页错误以及机器内部错误。

对应用程序和操作系统来说，80x86的中断和异常处理机制可以透明地处理发生的中断和异常事件。
当收到一个中断或检测到一个异常时，处理器会自动地把当前正在执行的程序或任务挂起，并开始运行中断或异常处理程序。
当处理程序执行完毕，处理器就会恢复并继续执行被中断的程序或任务。被中断程序的恢复过程并不会失去程序执行的连贯性，
除非从异常中恢复是不可能的或者中断导致当前运行程序被终止。本节描述保护模式中处理器中断和异常的处理机制。

异常和中断向量
--------------------------------------------------------------------------------

为了有助于处理异常和中断，每个需要被处理器进行特殊处理的处理器定义的异常和中断条件都被赋予了一个标识号，称为向量（vector）。
处理器把赋予异常或中断的向量用作中断描述符表IDT（Interrupt Descriptor Table）中的一个索引号，
来定位一个异常或中断的处理程序入口点位置。

允许的向量号范围是0～255。

* 其中0～31保留用作80x86处理器定义的异常和中断，不过目前该范围内的向量号并非每个都已定义了功能，未定义功能的向量号将留作今后使用。
* 范围在32～255的向量号用于用户定义的中断。这些中断通常用于外部I/O设备，使得这些设备可以通过外部硬件中断机制向处理器发送中断。
  下表中给出了为80x86定义的异常和NMI中断分配的向量。对于每个异常，该表给出了异常类型以及是否会产生一个错误码并保存在堆栈上。
  同时还给出了每个预先定义好的异常和NMI中断源。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/trap_and_idt_source.png

中断源和异常源
--------------------------------------------------------------------------------

### 中断源

处理器从两种地方接收中断：

* 外部(硬件产生)的中断。
* 软件产生的中断。

外部中断通过处理器芯片上两个引脚（INTR和NMI）接收。当引脚INTR接收到外部发生的中断信号时，
处理器就会从系统总线上读取外部中段控制器（如8259A）提供的中断向量号。当引脚NMI接收到信号时，
就产生一个非屏蔽中断。它使用固定的中断向量号2。任何通过处理器INTR引脚接收的外部中断都被称为可屏蔽硬件中断，
包括中断向量号0～255。标志寄存器EFLAGS中的IF标志可用来屏蔽所有这些硬件中断。

通过在指令操作数中提供中断向量号，INT n指令可用于从软件中产生中断。例如，指令INT 0x80会执行Linux的系统中断调用中断0x80。
向量0～255中的任何一个都可以用作INT指令的中断号。然而，如果使用了处理器预先定义的NMI向量，那么处理器对它的响应将与普通方式
产生的该NMI中断不同。如果NMI的向量号2用于该INT指令，就会调用NMI的中断处理器程序，但是此时并不会激活处理器的NMI处理硬件。

注意，EFLAGS中的IF标志不能够屏蔽使用INT指令从软件中产生的中断。

### 异常源

处理器接收的异常也有两个来源：

* 处理器检测到的程序错误异常。
* 软件产生的异常。

在应用程序或操作系统执行期间，如果处理器检测到程序错误，就会产生一个或多个异常。
80x86 处理器为其检测到的每个异常定义了一个向量。异常可以被细分为故障、陷阱和中止，见后面说明。

指令INT 0, INT 3和BOUND指令可以用来从软件中产生异常。这些指令可对指令流中指定点执行的特殊异常条件进行检查。
例如，INT 3指令会产生一个断点异常。

INT n指令可用于在软件中模拟指定的异常，但有一个限制。如果INT指令中的操作数n是80x86异常的向量号之一，
那么处理器将为该向量号产生一个中断，该中断就会去执行与该向量有关的异常处理程序。
但是因为这实际上是一个中断，所以处理器并不会把一个错误号压入堆栈，即使硬件产生的该向量相关的中断通常会产生一个错误码。
对于那些会产生错误码的异常，异常的处理程序会试图从堆栈上弹出错误码。因此，如果使用INT指令来模拟产生一个异常，
处理程序则会把EIP（正好处于缺少的错误码位置处）弹出堆栈，从而会造成返回位置错误。

##### 异常分类

根据异常被报告的方式以及导致异常的指令是否能够被重新执行，异常可被细分成故障（Fault）、陷阱（Trap）和中止（Abort）。

* Fault是一种通常可以被纠正的异常，并且一旦被纠正程序就可以继续运行。当出现一个Fault，处理器会把机器状态恢复到产生Fault的指令之前的状态。
  此时异常处理程序的返回地址会指向产生Fault的指令，而不是其后面一条指令。因此在返回后产生Fault的指令将被重新执行。

* Trap是一个引起陷阱的指令被执行后立刻会报告的异常。Trap也能够让程序或任务连贯地执行。
  Trap处理程序的返回地址指向引起陷阱指令的随后一条指令，因此在返回后会执行下一条指令。

* Abort是一种不会总是报告导致异常的指令的精确位置的异常，并且不允许导致异常的程序重新继续执行。
  Abort用于报告严重错误，例如硬件错误以及系统表中存在不一致性或非法值。

为了让程序或任务在一个异常或中断处理完之后能重新恢复执行，除了中止之外的所有异常都能报告精确的指令位置，并且所有中断保证是在指令边界上发生。

对于故障类异常，处理器产生异常时保存的返回指针指向出错指令。因为，当程序或任务在故障处理程序返回后重新开始执行时，原出错指令会被重新执行。
重新执行引发出错的指令通常用于处理访问指令操作数受阻的情况。Fault最常见的一个例子是页面故障（Page-fault）异常。
当程序引用不在内存中页面上的一个操作数时就会出现这种异常。当页故障异常发生时，异常处理程序可以把该页面加载到内存中并通过重新执行出错指令来恢复程序执行。
为了确保重新执行对于当前执行程序具有透明性，处理器会保存必要的寄存器和堆栈指针信息，以使得自己能够返回到执行出错指令之前的状态。

对于陷阱类异常，处理器产生异常时保存的返回指针指向引起陷阱操作的后一条指令。
如果在一条执行控制转移的指令执行期间检测到一个Trap，则返回指令指针会反映出控制的转移情况。
例如，在执行JMP指令时检测到一个Trap异常，那么返回指令指针会指向JMP指令的目标位置，而非JMP指令随后的一条指令。

中止类异常不支持可靠地重新执行程序或任务。中止异常的处理程序通常用来收集异常发生时有关处理器状态的诊断信息，并且尽可能恰当地关闭程序和系统。

中断会严格地支持被中断程序的重新执行而不会丢失任何连贯性。
中断所保存的返回指令指针指向处理器获取中断时将要执行的下一条指令边界处。
如果刚执行的指令有一个重复前缀，则中断会在当前重复结束并且寄存器已为下一次重复操作设置好时发生。

开启和禁止中断
--------------------------------------------------------------------------------

标志寄存器EFLAGS的中断允许标志IF（Interrupt enable Flag）能够禁止为处理器INTR引脚上收到的可屏蔽硬件中断提供服务。
当IF=0时，处理器禁止发送到INTR引脚的中断；当IF=1时，则发送到INTR引脚的中断信号会被处理器处理。

IF标志并不影响发送到NMI引脚的非屏蔽中断，也不影响处理器产生的异常。如同EFLAGS中的其他标志一样，处理器在响应硬件复位操作时会清除IF标志（IF=0）。

IF标志可以使用指令STI和CLI来设置或清除。只有当程序的CPL小于或等于IOPL时才可执行这两条指令，否则将引发一般保护性异常。

IF标志也会受以下操作的影响：
* PUSHF指令会把EFLAGS内容存入堆栈中，并且可以在那里被修改。而POPF指令可用于把已被修改过的标志内容放入EFLAGS寄存器中。
* 任务切换、POPF和IRET指令会加载EFLAGS寄存器。因此，它们可用来修改IF标志。
* 当通过中断门处理一个中断时，IF标志会被自动清除（复位），从而会禁止可屏蔽硬件中断。但如果是通过陷阱门来处理一个中断，则IF标志不会被复位。

异常和中断的优先级
--------------------------------------------------------------------------------

如果在一条指令边界有多个异常或中断等待处理时，处理器会按规定的次序对它们进行处理。
下表给出了异常和中断源类的优先级。处理器会首先处理最高优先级类中的异常或中断。
低优先级的异常会被丢弃，而低优先级的中断则会保持等待。
当中断处理程序返回到产生异常和/或中断的程序或任务时，被丢弃的异常会重新发生。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/trap_idt_priority.png

中断描述符表
--------------------------------------------------------------------------------

中断描述符表（Interrupt Descriptor Table，IDT）: 将每个异常或中断向量分别与它们的处理过程联系起来。
与GDT和LDT表类似，IDT也是由8字节长描述符组成的一个数组。与GDT不同的是，表中第1项可以包含描述符。
为了构成IDT表中的一个索引值，处理器把异常或中断的向量号乘以8。因为最多只有256个中断或异常向量，
所以IDT无需包含多于256个描述符。IDT中可以含有少于256个描述符，因为只有可能发生的异常或中断才需要描述符。
不过IDT中所有空描述符项应该设置其存在位（标志）为0。

IDT表可以驻留在线性地址空间的任何地方，处理器使用IDTR寄存器来定位IDT表的位置。
这个寄存器中含有IDT表32位的基地址和16位的长度（限长）值，

如下图所示： IDT表基地址应该对齐在8字节边界上以提高处理器的访问效率。限长值是以字节为单位的IDT表的长度。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/idt.png

LIDT和SIDT指令分别用于加载和保存IDTR寄存器的内容:

* LIDT指令用于把内存中的限长值和基地址操作数加载到IDTR寄存器中。
  该指令仅能由当前特权级CPL是0的代码执行，通常被用于创建IDT时的操作系统初始化代码中。
* SIDT指令用于把IDTR中的基地址和限长内容复制到内存中。该指令可在任何特权级上执行。

如果中断或异常向量引用的描述符超过了IDT的界限，处理器会产生一个一般保护性异常。

### IDT描述符

IDT表中可以存放3种类型的门描述符：中断门(Interrupt gate)描述符、陷阱门(Trap gate)描述符、任务门(Task gate)描述符。

下图给出了这三种门描述符的格式:

中断门和陷阱门含有一个长指针（即段选择符和偏移值），处理器使用这个长指针把程序执行权转移到代码段中异常或中断的处理过程中。
这两个段的主要区别在于处理器操作EFLAGS寄存器IF标志上。

IDT中任务门描述符的格式与GDT和LDT中任务门的格式相同。任务门描述符中含有一个任务TSS段的选择符，该任务用于处理异常或中断。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/idt_descriptor.png

### 异常与中断处理

处理器对异常和中断处理过程的调用操作方法与使用CALL指令调用程序过程和任务的方法类似。
当响应一个异常或中断时，处理器使用异常或中断的向量作为IDT表中的索引。
如果索引值指向中断门或陷阱门，则处理器使用与CALL指令操作调用门类似的方法调用异常或中断处理过程。
如果索引值指向任务门，则处理器使用与CALL指令操作任务门类似的方法进行任务切换，执行异常或中断的处理任务。

异常或中断门引用运行在当前任务上下文中的异常或中断处理过程，如下图所示:

门中的段选择符指向GDT或当前LDT中的可执行代码段描述符。门描述符中的偏移字段指向异常或中断处理过程的开始处。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/idt_process.png

当处理器执行异常或中断处理过程调用时会进行以下操作：

##### 如果处理过程将在高特权级（如0级）上执行时就会发生堆栈切换操作。堆栈切换过程如下：

处理器从当前执行任务的TSS段中得到中断或异常处理过程使用的堆栈的段选择符和栈指针（例如tss.ss0、tss.esp0）。
然后处理器会把被中断程序（或任务）的栈选择符和栈指针压入新栈中，如下图所示:

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/stack_schdule.png

接着处理器会把EFLAGS、CS和EIP寄存器的当前值也压入新栈中。
如果异常会产生一个错误号，那么该错误号也会被最后压入新栈中。

##### 如果处理过程将在被中断任务同一个特权级上运行，那么：

处理器把EFLAGS、CS和EIP寄存器的当前值保存在当前堆栈上。
如果异常会产生一个错误号，那么该错误号也会被最后压入新栈中。

为了从中断处理过程中返回，处理过程必须使用IRET指令。
IRET指令与RET指令类似，但IRET还会把保存的寄存器内容恢复到EFLAGS中。
不过只有当CPL是0时才会恢复EFLAGS中的IOPL字段，并且只有当CPL不大于IOPL时，IF标志才会被改变。
如果当调用中断处理过程时发生了堆栈切换，那么在返回时IRET指令会切换到原来的堆栈。

1.异常和中断处理过程的保护

异常和中断处理过程的特权级保护机制与通过调用门调用普通过程类似。
处理器不允许把控制转移到比CPL更低特权级代码段的中断处理过程中，否则将产生一个一般保护性异常。
另外，中断和异常的保护机制在以下方面与一般调用门过程不同：

因为中断和异常向量没有RPL，因此在隐式调用异常和中断处理过程时不会检查RPL。

只有当一个异常或中断是由INT n、INT 3或INT 0指令产生时，处理器才会检查中断或陷阱门中的DPL。
此时CPL必须小于或等于门的DPL。这个限制可以防止运行在特权级3的应用程序使用软件中断访问重要的异常处理过程，
例如页错误处理过程，假设这些处理过程已被存放在更高特权级的代码段中。
对于硬件产生的中断和处理器检测到的异常，处理器会忽略中断门和陷阱门中的DPL。

因为异常和中断通常不会定期发生，因此这些有关特权级的规则有效地增强了异常和中断处理过程能够运行的特权级限制。
我们可以利用以下技术之一来避免违反特权级保护：
异常或中断处理程序可以存放在一个一致性代码段中。这个技术可以用于只需访问堆栈上数据的处理过程（如除出错异常）。
如果处理程序需要数据段中的数据，那么特权级3必须能够访问这个数据段。但这样一来就没有保护可言了。

处理过程可以放在具有特权级0的非一致代码段中。这种处理过程总是可以执行的，与被中断程序或任务的当前特权级CPL无关。

2. 异常或中断处理过程的标志使用方式

当通过中断门或陷阱门访问一个异常或中断处理过程时，处理器会在把EFLAGS寄存器内容保存到堆栈上之后清除EFLAGS中的TF标志。
清除TF标志可以防止指令跟踪影响中断响应。而随后的IRET指令会用堆栈上的内容恢复EFLAGS的原TF标志。

中断门与陷阱门唯一的区别在于处理器操作EFLAGS寄存器IF标志的方法。
当通过中断门访问一个异常或中断处理过程时，处理器会复位IF标志以防止其他中断干扰当前中断处理过程。
随后的IRET指令则会用保存在堆栈上的内容恢复EFLAGS寄存器的IF标志。而通过陷阱门访问处理过程并不会影响IF标志。

3. 执行中断处理过程的任务

当通过IDT表中任务门访问异常或中断处理过程时，就会导致任务切换。从而可以在一个专用任务中执行中断或异常处理过程。
IDT表中的任务门引用GDT中的TSS描述符。切换到处理过程任务的方法与普通任务切换一样。

**中断处理任务**:

当通过IDT中任务门来访问异常或中断处理过程时就会导致任务切换。使用单独的任务来处理异常或中断有如下好处：

* 被中断程序或任务的完整上下文会被自动保存。
* 在处理异常或中断时，新的TSS可以允许处理过程使用新特权级0的堆栈。
  在当前特权级0的堆栈已毁坏时如果发生了一个异常或中断，那么在为中断过程提供一个新特权级0的堆栈条件下，通过任务门访问中断处理过程能够防止系统崩溃。
* 通过使用单独的LDT给中断或异常处理任务独立的地址空间，可以把它与其他任务隔离开来。

使用独立任务处理异常或中断的不足之处是：

* 在任务切换时必须对大量机器状态进行保存，使得它比使用中断门的响应速度要慢，导致中断延时增加。
* IDT中的任务门会引用GDT中的TSS描述符，如下图所示:
  切换到句柄任务的过程与普通任务切换过程相同。到被中断任务的反向链接会被保存在句柄任务TSS的前一任务链接字段中。
  如果一个异常会产生一个出错码，则该出错码会被复制到新任务堆栈上。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/idt_task.png

错误码
--------------------------------------------------------------------------------

当异常条件与一个特定的段相关时，处理器会把一个错误码压入异常处理过程的堆栈上。
错误码的格式如下图所示：

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/error_code.png

错误码很像一个段选择符，但是最低3位不是TI和RPL字段，而是以下3个标志：
位0是外部事件EXT（External event）标志。当置位时，表示执行程序以外的事件造成了异常，如硬件中断。
* 位1是描述符位置IDT（Descriptor location）标志。
  当该位置位时，表示错误码的索引部分指向IDT中的一个门描述符。当该位复位时，表示索引部分指向GDT或LDT中的一个段描述符。
* 位2是GDT/LDT表选择标志TI。只有当位1的IDT=0才有用。
  当该TI=1时，表示错误码的索引部分指向LDT中的一个描述符。当TI=0时，说明错误码中的索引部分指向GDT表中的一个描述符。

段选择索引字段提供了错误码引用的IDT、GDT或者当前LDT中段或门描述符的索引值。在某些情况下错误码是空的（即低16位全0）。
空错误码表示错误不是由于引用某个特定段造成，或者是在操作中引用了一个空段描述符。

页故障（Page-fault）异常的错误码格式与上面的不同，如下图所示：

只有最低3位有用，它们的名称与页表项中的最后3位相同（U/S、W/R、P）。含义和作用分别是：
* 位0（P），异常是由于页面不存在或违反访问特权而引发。P=0，表示页不存在；P=1表示违反页级保护权限。
* 位1（W/R），异常是由于内存读或写操作引起。W/R=0，表示由读操作引起；W/R=1，表示由写操作引起。
* 位2（U/S），发生异常时CPU执行的代码级别。U/S=0，表示CPU正在执行超级用户代码；U/S=1，表示CPU正在执行一般用户代码。
另外，处理器还会把引起页面故障异常的线性地址存放在CR2中。页出错异常处理程序可以使用这个地址来定位相关的页目录和页表项。

注意，错误不会被IRET指令自动弹出堆栈，因此中断处理程序在返回之前必须清除堆栈上的错误码。
另外，虽然处理产生的某些异常会产生错误码并会自动保存到处理过程的堆栈中，但是外部硬件中断
或程序执行INT n指令产生的异常并不会把错误码压入堆栈中。

https://github.com/leeminghao/doc-linux/tree/master/arch/x86/page_error.png